print "In INT 7";
alias physicalSP S0;
physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);
alias sysCallNo S1;
sysCallNo = [physicalSP - 1];
//print "sysCallNo";
//print sysCallNo;
alias currentPID S2;
currentPID = (PTBR - 1024) / 8;
//print "currentPID";
//print currentPID;
breakpoint;
alias newPID S3;
if (sysCallNo == 10) then	//Exit System Call
	newPID = 0;
	alias currentPCB S4;
	currentPCB = READY_LIST + 32 * currentPID;
	[ currentPCB + 1 ] = 0; 	// Set STATE to OVER
//	breakpoint;
	while (newPID < 32) do
		//print "Checking ";	
		newPID = newPID+1;
		//print newPID;
		if ([READY_LIST + 32 * newPID +1]==(currentPID+100)) then
			[READY_LIST + 32 * newPID +1] = 1;
		endif;
	endwhile;
	
	newPID = 0;
	
	while (newPID<32) do
		//print "Checking ";	
		//print newPID;
		if ([READY_LIST + 32 * newPID +1]==1) then
			break;
		endif;
		newPID = newPID+1;
		if(newPID == 32) then
			halt;
		endif;
	endwhile;
	//print "RobbinOver";
	
	//print "newPID";
	//print newPID;

	
	alias newPCB S5;
	newPCB = READY_LIST + 32 * newPID;
	
	alias currentPTBR S6;
	currentPTBR = PAGE_TABLE + currentPID * 8;
	
	//Close the files
	//
	//
	//	
	// Get the Start of Per Process Table
	alias PPFTStart S9;
	PPFTStart = currentPCB + 15;
	alias fileDescriptor S10;
	fileDescriptor = PPFTStart;
	PPFTStart = PPFTStart + 16;
	while(fileDescriptor<PPFTStart) do
		//print "fileDescript";
		//print fileDescriptor;
		// Check if the Entry there is Valid
		if([fileDescriptor] == -1) then
			//print "Invalid SWOT";
			fileDescriptor = fileDescriptor + 2;
			continue;
		endif;
		
		// Get the SWOTindex 
		alias SWOTindex S11;
		SWOTindex = FILE_TABLE + 2*[fileDescriptor] + 1;
		// Check this wierd stuff ^
		
		// Decrement File Open Count
		[SWOTindex] = [SWOTindex] - 1;
		
		// Check if it Zero
		if([SWOTindex]==0) then
			[SWOTindex-1] = -1;
		endif;
		
		// Remove the Entry from PPFT
		[fileDescriptor] = -1;
		[fileDescriptor + 1] = -1;
		fileDescriptor = fileDescriptor + 2;
		//print "Got Here";
	endwhile;
	//
	//
	//
	
	alias page S7;
	page = 0;
	while(page<4) do
		//print "page";
		//print page;
		//print [currentPTBR + page];
		if([currentPTBR + page]!=-1) then
			[MEM_LIST + [currentPTBR + page]] = 0;
		endif;
		[currentPTBR + page] = -1;
		[currentPTBR + page] = "00";
		page = page + 2;
	endwhile;
	
	[ newPCB + 1 ] = 2; 	// Set STATE to READY
	BP = [ newPCB + 2 ];	//
	SP = [ newPCB + 3 ]; 	//
	PTBR = [ newPCB + 5 ];	//
	PTLR = [ newPCB + 6 ];	//
	R0 = [ newPCB + 7 ];	//
	R1 = [ newPCB + 8 ];	// Copy Back the values
	R2 = [ newPCB + 9 ];	//
	R3 = [ newPCB + 10 ]; 	//
	R4 = [ newPCB + 11 ]; 	//
	R5 = [ newPCB + 12 ]; 	//
	R6 = [ newPCB + 13 ]; 	//
	R7 = [ newPCB + 14 ];	//
	SP = SP + 1; 			// Make space for storing the IP on top as after interrupt it is loaded from there
	alias newphysicalSP S8; 
	newphysicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512); 
	[ newphysicalSP ] = [ newPCB + 4 ]; 
	[physicalSP - 2] = 0;
	breakpoint;
	ireturn;
endif;
if (sysCallNo == 13) then	//Wait System Call
	alias waitingPID S4;
	waitingPID = [physicalSP - 3];
	currentPID = (PTBR - 1024) / 8;
	
	// Check if it is Valid
	if(waitingPID<0 || waitingPID>31) then
		[physicalSP - 2] = -1;
//		print "invalidWait";
		ireturn;
	endif;
	
	// Check if both are same
	if(currentPID == waitingPID) then
		[physicalSP - 2] = -1;
//		print "curr=wait";
		ireturn;
	endif;
	
	// Check if wait is already over
	if([READY_LIST + 32 * waitingPID +1]==0) then
		[physicalSP - 2] = -1;
//		print "wait dead";
		ireturn;
	endif;

	newPID = waitingPID + 100;
	while(newPID>=100) do
		if(currentPID + 100 == newPID) then
			[physicalSP - 2] = -1;
			print "CyclicDep";
			ireturn;
		endif;
		newPID = newPID - 100;
		newPID = [READY_LIST + 32 * newPID +1];
	endwhile;
	
	
	alias currentPCB S6;
	currentPCB = READY_LIST + 32 * currentPID;
	[ currentPCB + 1 ]= waitingPID + 100;	//Change the state to wait
	[ currentPCB + 2 ] = BP;		// Save BP
	[ currentPCB + 3 ] = SP - 1; 	// Save SP. -1 coz interrupt pushed the IP in Stack
	[ currentPCB + 4 ] = [ physicalSP ]; // Save IP of current process in the PCB from the stack
	[ currentPCB + 5 ] = PTBR;		// Save PTBR
	[ currentPCB + 6 ] = PTLR;		// Save PTLR
	[ currentPCB + 7 ] = R0;		//
	[ currentPCB + 8 ] = R1;		//
	[ currentPCB + 9 ] = R2;		//	Save the Registers
	[ currentPCB + 10 ] = R3;		//
	[ currentPCB + 11 ] = R4;		//
	[ currentPCB + 12 ] = R5;		//
	[ currentPCB + 13 ] = R6;		//
	[ currentPCB + 14 ] = R7;		//
	
//Find the New Process to Take
//	alias newPID S5;
	newPID = 0;
	while (newPID<32) do
		//print "Checking ";	
		//print newPID;
		if ([READY_LIST + 32 * newPID +1]==1) then
			break;
		endif;
		newPID = newPID+1;
		if(newPID == 32) then
			halt;
		endif;
	endwhile;
	//print "RobbinOver";
// Resume the New Process Found	
	alias newPCB S7;
	newPCB = READY_LIST + 32 * newPID;
	[ newPCB + 1 ] = 2; 	// Set STATE to READY
	BP = [ newPCB + 2 ];	//
	SP = [ newPCB + 3 ]; 	//
	PTBR = [ newPCB + 5 ];	//
	PTLR = [ newPCB + 6 ];	//
	R0 = [ newPCB + 7 ];	//
	R1 = [ newPCB + 8 ];	// Copy Back the values
	R2 = [ newPCB + 9 ];	//
	R3 = [ newPCB + 10 ]; 	//
	R4 = [ newPCB + 11 ]; 	//
	R5 = [ newPCB + 12 ]; 	//
	R6 = [ newPCB + 13 ]; 	//
	R7 = [ newPCB + 14 ];	//
	SP = SP + 1; 			// Make space for storing the IP on top as after interrupt it is loaded from there
	alias newphysicalSP S8; 
	newphysicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512); 
	[ newphysicalSP ] = [ newPCB + 4 ]; 
	[physicalSP - 2] = 0;
//	breakpoint;
	ireturn;
endif;
if (sysCallNo == 14) then	//Signal System Call
	newPID = 0;
	
	while (newPID<32) do
		//print "Checking ";	
		//print newPID;
		if ([READY_LIST + 32 * newPID +1]==(currentPID+100)) then
			[READY_LIST + 32 * newPID +1] = 1;
		endif;
		newPID = newPID + 1;
	endwhile;
	[physicalSP - 2] = 0;
	ireturn;
endif;
[physicalSP - 2] = -1;
//print "InvalidSYSCall";
ireturn;