//print "In INT 7";
alias physicalSP S0;
physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);
alias sysCallNo S1;
sysCallNo = [physicalSP - 1];
if (sysCallNo == 10) then	//Exit System Call
	alias currentPID S2;
	currentPID = (PTBR - 1024) / 8;
	alias newPID S3;
	newPID = currentPID;
	alias currentPCB S4;
	currentPCB = READY_LIST + 32 * currentPID;
	while (1) do
//		print "Checking ";	
		newPID = (newPID+1)%32;
	//	//print newPID;
		if ([READY_LIST + 32 * newPID +1]==1) then
			break;
		endif;
		if(newPID == currentPID) then
			break;
		endif;
	endwhile;
	//print "RobbinOver";
	if (currentPID==newPID) then
		halt;
	endif;
	
	alias newPCB S5;
	newPCB = READY_LIST + 32 * newPID;
	
	alias currentPTBR S6;
	currentPTBR = PAGE_TABLE + currentPID * 8;
	
	//Close the files
	//
	//
	//	
	// Get the Start of Per Process Table
	alias PPFTStart S9;
	PPFTStart = currentPCB + 15;
	alias fileDescriptor S10;
	fileDescriptor = 0;
	while(fileDescriptor<8) do
//		print "fileDescript";
//		print fileDescriptor;
		// Check if the Entry there is Valid
		if([PPFTStart+2*fileDescriptor] == -1) then
			//print "Invalid SWOT";
			fileDescriptor = fileDescriptor + 1;
			continue;
		endif;
		
		// Get the SWOTindex 
		alias SWOTindex S11;
		SWOTindex = [PPFTStart+2*fileDescriptor];
		
		// Decrement File Open Count
		[FILE_TABLE + 2*SWOTindex + 1] = [FILE_TABLE + 2*SWOTindex + 1] - 1;
		
		// Check if it Zero
		if([FILE_TABLE + 2*SWOTindex + 1]==0) then
			[FILE_TABLE + 2*SWOTindex] = -1;
		endif;
		
		// Remove the Entry from PPFT
		[PPFTStart+2*fileDescriptor] = -1;
		[PPFTStart+2*fileDescriptor + 1] = -1;
		fileDescriptor = fileDescriptor + 1;
//		print "Got Here";
	endwhile;
	//
	//
	//
	
	[ currentPCB + 1 ] = 0; 	// Set STATE to OVER
	
	alias page S7;
	page = 0;
	while(page<4) do
//		print "page";
//		print page;
		if([currentPTBR + page*2 + 0]!=-1) then
			[MEM_LIST + [currentPTBR + page*2 + 0]] = 0;
		endif;
		[currentPTBR + page*2 + 0] = -1;
		[currentPTBR + page*2 + 1] = "00";
		page = page + 1;
	endwhile;
	
	[ newPCB + 1 ] = 2; 	// Set STATE to READY
	BP = [ newPCB + 2 ];	//
	SP = [ newPCB + 3 ]; 	//
	PTBR = [ newPCB + 5 ];	//
	PTLR = [ newPCB + 6 ];	//
	R0 = [ newPCB + 7 ];	//
	R1 = [ newPCB + 8 ];	// Copy Back the values
	R2 = [ newPCB + 9 ];	//
	R3 = [ newPCB + 10 ]; 	//
	R4 = [ newPCB + 11 ]; 	//
	R5 = [ newPCB + 12 ]; 	//
	R6 = [ newPCB + 13 ]; 	//
	R7 = [ newPCB + 14 ];	//
	SP = SP + 1; 			// Make space for storing the IP on top as after interrupt it is loaded from there
	alias newphysicalSP S8; 
	newphysicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512); 
	[ newphysicalSP ] = [ newPCB + 4 ]; 
		
	ireturn;
endif;
[physicalSP - 2] = -1;
//print "InvalidSYSCall";
ireturn;