//print "In INT 5";
alias parentPhySP S0;
parentPhySP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);
alias parentPID S1;
parentPID = (PTBR - 1024) / 8;

alias sysCallNo S2;
sysCallNo = [parentPhySP - 1];
breakpoint;
//print "sysCallNo=";
//print sysCallNo;

if (sysCallNo == 8) then
	// Implementation of Fork

	// Find Free PCB for Child
	alias PCBSlot S3;
	PCBSlot = 0;
	while ( PCBSlot <  64) do					// 64 entries, each of size 2 words
		if([ READY_LIST + 32*PCBSlot + 1] ==  0) then
			//print "PCBSlot=";
			//print PCBSlot;	
			break;
		endif;
		PCBSlot = PCBSlot + 1;					// Move to next entry
	endwhile;
	
	if(PCBSlot==64) then
		//print "No PCBSlot";
		[parentPhySP - 2] = -1;
		ireturn;
	endif;
	
	//Set the PID 
	[READY_LIST + PCBSlot * 32 + 0] = PCBSlot; 
	
	alias parentPTBR S5;
	parentPTBR = PAGE_TABLE + parentPID * 8;
	alias childPTBR S6;
	childPTBR = PAGE_TABLE + PCBSlot * 8;
	
	alias i S4;
	alias page S7;
	i = 25;
	page = 0;
	
	//print "here";
	
	while(page < 4) do 
		if([parentPTBR + page*2 + 0] != -1) then
			while(i<64) do
				if([ MEM_LIST + i]==0) then
					//print "page";
					//print page;
					//print i;
					[childPTBR + page*2 + 0] = i;
					[childPTBR + page*2 + 1] = [parentPTBR + page*2 + 1];
					i = i + 1;
					break;
				endif;
				i = i + 1;
			endwhile;
			if(i==64) then
				//print "No Free Page1";
				[parentPhySP - 2] = -1;
				ireturn;
			endif;
		else
			[childPTBR + page*2 + 0] = -1;
			[childPTBR + page*2 + 1] = [parentPTBR + page*2 + 1];
		endif;
		page = page + 1;
	endwhile;	
	
	page = 0;
	while(page < 4) do 
		if([childPTBR + page*2 + 0]!=-1) then
			[MEM_LIST + [childPTBR + page*2 + 0]] = 1; 
			i = 0;
			while(i<512) do
				[[childPTBR + page*2 + 0]*512 + i] = [[parentPTBR + page*2 + 0]*512 + i];
				i = i + 1;
			endwhile;
		endif;
		page = page + 1;
	endwhile;
	
	alias parentPCB S8;
	parentPCB = READY_LIST + parentPID * 32;
	alias childPCB S9;
	childPCB = READY_LIST + PCBSlot * 32;
	
	[childPCB + 5] = childPTBR;
	[childPCB + 4] = [parentPhySP];
//	//print "Child IP";
//	//print [parentPhySP];
	[childPCB + 3] = SP - 1;
	[ childPCB + 2 ] = BP;		// Save BP
	[ childPCB + 6 ] = [parentPCB + 6];		// Save PTLRpdjpdfjgpdjfpgdfgjdiogfdogfdogndofin
	[ childPCB + 7 ] = R0;		//
	[ childPCB + 8 ] = R1;		//
	[ childPCB + 9 ] = R2;		//	Save the Registers
	[ childPCB + 10 ] = R3;		//
	[ childPCB + 11 ] = R4;		//
	[ childPCB + 12 ] = R5;		//
	[ childPCB + 13 ] = R6;		//
	[ childPCB + 14 ] = R7;		//
	
	while(i<16) do
		[childPCB + 15 +  i + 0] = [parentPCB + 15 +  i + 0];
		[childPCB + 15 +  i + 1] = [parentPCB + 15 +  i + 1];
		if([childPCB + 15 +  i + 1]!=-1) then
			[[childPCB + 15 +  i]*2+1]=[[childPCB + 15 +  i]*2+1]+1;
		endif;
		i = i + 2;
	endwhile;

	[childPCB + 1] = 1;
	
	[parentPhySP - 2] = PCBSlot;
	
	alias childPhySP S10;
	childPhySP = ([childPTBR + 2 * ((SP-1) / 512)] * 512) + ((SP-1) % 512);
	
	[childPhySP - 1] = -2;
	breakpoint;
	ireturn;
	
endif;
[parentPhySP - 2] = -1;
//print "InvalidSYSCall";
ireturn;